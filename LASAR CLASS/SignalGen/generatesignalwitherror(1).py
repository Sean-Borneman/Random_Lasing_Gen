# -*- coding: utf-8 -*-
"""GenerateSignalWithError.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qrbSA5WHM-SdEcSG39fLIKVi8nUhbbXI
"""

###CONSTANTS
INITIAL_NUM_FAKE_SAMPLES = 100
FREQUENCY_ERROR = 1
AMPLITUDE_ERROR = 1
GENRAL_ERROR_AMPLITUDE = 10
DEVIATION_THRESHOLD = 100
DEVIATION_FILTER = True

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import random

total_time = 2.0      # Total time duration of the signal in seconds
sampling_rate = 1000  # Sampling rate in Hz (samples per second)
# Generate time values
time = np.linspace(0, total_time, int(sampling_rate * total_time), endpoint=False)
frequencies = np.fft.fftfreq(len(time), 1 / sampling_rate)
time_signals = []
for i in range(INITIAL_NUM_FAKE_SAMPLES):
  sampling_rate = 1000  # Sampling rate in Hz (samples per second)
  classic_frequency = 5.0 + random.uniform(-FREQUENCY_ERROR,FREQUENCY_ERROR)     # Frequency of the signal in Hz
  classic_amplitude = 3.0 + random.uniform(-AMPLITUDE_ERROR,AMPLITUDE_ERROR)       # Amplitude of the signal
  lasing_frequency = 10.0+ random.uniform(-FREQUENCY_ERROR,FREQUENCY_ERROR)
  lasing_amplitude = 5.0+ random.uniform(-AMPLITUDE_ERROR,AMPLITUDE_ERROR)

  # Generate a time-domain signal (sinusoidal signal)
  time_domain_signal = classic_amplitude * np.sin(2 * np.pi * classic_frequency * time)
  time_domain_signal += lasing_amplitude * np.sin(2 * np.pi * lasing_frequency * time)
  unique_signal = np.abs(np.fft.fft(time_domain_signal))
  for i in range(len(unique_signal)):
    #add uniform error
    unique_signal[i] = unique_signal[i] + random.uniform(-1*GENRAL_ERROR_AMPLITUDE,GENRAL_ERROR_AMPLITUDE)

  if(unique_signal[0] > 10000):
    print("ALERT")
    print(classic_frequency)
    print(classic_amplitude)
    print(lasing_frequency)
    print(lasing_amplitude)
  time_signals.append(unique_signal)

plt.figure(figsize=(10, 5))
plt.plot(frequencies, time_signals[65])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power')
plt.title('Power Spectrum')
plt.grid(True)
plt.xlim(0)
plt.show()

#Calculate Average
#sum = time_signals[99]
#average = time_signals[0]
sum = 0
for i in range(len(time_signals)):
  sum += time_signals[i]
average = sum/len(time_signals)

plt.figure(figsize=(10, 5))
plt.plot(frequencies, average)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power')
plt.title('Average Power Spectrum')
plt.grid(True)
plt.xlim(0)
plt.show()

import math
#Average deviation
deviations = []
counter = 0
total_deviation = 0
for i in range(len(time_signals)):
  for j in range(len(time_signals[i])):
    counter +=1
    deviation = average[j] - time_signals[i][j]
    total_deviation += math.sqrt((average[j] - time_signals[i][j])**2)
    if((abs(deviation) > DEVIATION_THRESHOLD) and (DEVIATION_FILTER == True)):
      pass
    else:
      deviations.append(deviation)

average_deviation = total_deviation / counter
print(average_deviation)

print(random.uniform(-1*average_deviation,average_deviation) )
new_signal = []
for i in range(len(average)):
  new_signal.append(average[i] + random.uniform(-1*average_deviation,average_deviation))

plt.figure(figsize=(10, 5))
plt.plot(frequencies, new_signal)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power')
plt.title('Power Spectrum With Unifrom Error')
plt.grid(True)
plt.xlim(0)
plt.show()

#New_signal to time domain
time_signal_noise = np.fft.ifft(new_signal)
# Plot the time-domain signal
plt.figure(figsize=(10, 5))
plt.plot(time, time_signal_noise)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Time-Domain Signal WIth Uniform Error')
plt.grid(True)

#New_signal to time domain
time_signal_noise = np.fft.ifft(average)
# Plot the time-domain signal
plt.figure(figsize=(10, 5))
plt.plot(time, time_signal_noise)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Average Time-Domain Signal')
plt.grid(True)

import numpy as np
from scipy import stats


dist = stats.norm
bounds = [(-30, 30), (0,100)]
#bounds = [(0,30), (0,1)]
dist = stats.fit(dist,deviations, bounds)
#res = stats.fit(dist, average, bounds)

# fig, ax = plt.subplots(1,1)
# ax.plot(time, dist.pdf(time), 'k-', lw=2, label='frozen pdf')
dist.plot()
#plt.hist(deviations)
plt.show()

list = []
for i in range(200):
  list.append(i-100)
print(list)

print(dist.params)
sample = stats.norm.rvs(loc= dist.params.loc,scale = dist.params.scale, size=430000, random_state=None)
#sample = stats.gamma.rvs(dist.params.a, dist.params.loc, dist.params.scale, size=430000, random_state=None)
posSample = []
for i in sample:
    posSample.append(i)

plt.hist(posSample, bins=list)
#plt.hist(sample, bins=10)
plt.xlabel('Value')
plt.ylabel('Counts')
plt.title('Samples from fit distribution')
plt.show()

plt.hist(deviations, bins=list)
plt.xlabel('Value')
plt.ylabel('Counts')
plt.title('Error from Average')
plt.show()

"""# Problem: The tails of each distribution are not similar
Solutions: Try differant disribution
#Progress


*   Generate Fake data
*   Calculate the Average of the Fake data
*   Fit distribution to the error from average
#TODO
*   Make new data by addign error sampled from the distribution to the average
*   Quantify Error of Fit Distribution (RMSE)
*   Also all your errors are positive rn for no reason pls fix
*   Error values are mostly 0 b/c your only adding error to frequency and amplitude







"""

new_signal_dist_error = []
for i in range(len(average)):
  sample = stats.norm.rvs(loc= dist.params.loc,scale = dist.params.scale, size=1, random_state=None)
  #sample = stats.dgamma.rvs(dist.params.a, dist.params.loc, dist.params.scale, size=1, random_state=None)
  new_signal_dist_error.append(average[i] + sample[0])

plt.figure(figsize=(10, 5))
plt.plot(frequencies, new_signal_dist_error)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power')
plt.title('Average Power Spectrum With Distributed Error')
plt.grid(True)
plt.xlim(0)
plt.show()

#New_signal to time domain
time_signal_noise = np.fft.ifft(new_signal_dist_error)
# Plot the time-domain signal
plt.figure(figsize=(10, 5))
plt.plot(time, time_signal_noise)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Time-Domain Signal WIth Distributed Error')
plt.grid(True)