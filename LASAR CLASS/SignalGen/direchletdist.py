# -*- coding: utf-8 -*-
"""DirechletDist

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e6TC-A06jEZYz5o0DZsaPYU7BZLHFRr7

# Method


*   Generate fake data samples
*   Get Direchlet distribution length n
*   Add a scalar of each sample based on respective direchlet value
"""

from scipy.stats import dirichlet
import random
from scipy import signal
import matplotlib.pyplot as plt
import numpy as np
INITIAL_NUM_FAKE_SAMPLES = 100
FREQUENCY_ERROR = 0
AMPLITUDE_ERROR = 0
GENRAL_ERROR_AMPLITUDE = 10
DEVIATION_THRESHOLD = 100
DEVIATION_FILTER = True

# Same fake data Gen as Average+Error method

# Sampling rate in Hz (samples per second)
# Generate time values
time = np.linspace(0, total_time, int(
    sampling_rate * total_time), endpoint=False)
frequencies = np.fft.fftfreq(len(time), 1 / sampling_rate)
time_signals = []
for i in range(INITIAL_NUM_FAKE_SAMPLES):
    sampling_rate = 1000  # Sampling rate in Hz (samples per second)
    # Frequency of the signal in Hz
    classic_frequency = 5.0 + random.uniform(-FREQUENCY_ERROR, FREQUENCY_ERROR)
    # Amplitude of the signal
    classic_amplitude = 3.0 + random.uniform(-AMPLITUDE_ERROR, AMPLITUDE_ERROR)
    lasing_frequency = 10.0 + random.uniform(-FREQUENCY_ERROR, FREQUENCY_ERROR)
    lasing_amplitude = 5.0 + random.uniform(-AMPLITUDE_ERROR, AMPLITUDE_ERROR)

    # Generate a time-domain signal (sinusoidal signal)
    time_domain_signal = classic_amplitude * \
        np.sin(2 * np.pi * classic_frequency * time)
    time_domain_signal += lasing_amplitude * \
        np.sin(2 * np.pi * lasing_frequency * time)
    unique_signal = np.abs(np.fft.fft(time_domain_signal))
    for i in range(len(unique_signal)):
        # add uniform error
        unique_signal[i] = unique_signal[i] + \
            random.uniform(-1*GENRAL_ERROR_AMPLITUDE, GENRAL_ERROR_AMPLITUDE)

    if (unique_signal[0] > 10000):
        print("ALERT")
        print(classic_frequency)
        print(classic_amplitude)
        print(lasing_frequency)
        print(lasing_amplitude)

    time_signals.append(unique_signal)

plt.figure(figsize=(10, 5))
plt.plot(frequencies, time_signals[4])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Power')
plt.title('Power Spectrum')
plt.grid(True)
plt.xlim(0)
plt.show()

# alpha is the weight of each
alpha = [1 for i in range(INITIAL_NUM_FAKE_SAMPLES)]

distributions = dirichlet.rvs(alpha, size=1, random_state=1)
sum = 0
for entry in distributions[0]:
    sum += entry
print(sum)

xaxis = list(range(1, INITIAL_NUM_FAKE_SAMPLES+1))
plt.figure(figsize=(10, 5))
plt.plot(xaxis, distributions[0])
plt.xlabel('Alpha')
plt.ylabel('Power')
plt.title('Power Spectrum')
plt.grid(True)
plt.xlim(0)
plt.show()

nList = [0, 24, 30, 100]
nList2 = [1, 2, 2, 4]
nList2 = np.array(nList2)
nList = np.array(nList)
print(nList2*nList)

print(nList+nList2)

new_signal = [0 for i in range(int(total_time*sampling_rate))]

for i in range(0, INITIAL_NUM_FAKE_SAMPLES):
    new_signal += np.array(time_signals[i]) * distributions[0][i]

xaxis = list(range(1, INITIAL_NUM_FAKE_SAMPLES+1))
plt.figure(figsize=(10, 5))
plt.plot(frequencies, list(new_signal))
plt.xlabel('Alpha')
plt.ylabel('Power')
plt.title('Power Spectrum')
plt.grid(True)
plt.xlim(0)
plt.show()
